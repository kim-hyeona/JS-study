// 객체 자료형 자세히 살펴보기
/* 
  자바스크립트에서 원시 자료형을 제외한 모든 자료형은 객체 자료형이다
  배열/함수 역시 객체 자료형이며 자바스크립트는 다른 언어와 달리 배열과 함수를 사용할 시 주의해야할 점이 많단
*/

// 배열과 함수가 객체인 이유
/* 
  자바스크립트의 원시 자료형을 제외한 모든 자료형은 객체 자료형이다
  따라서 논리적으로 배열과 함수 역시 객체 자료형이 된다
*/


// 배열
/* 
  배열은 인덱스로 연속적인 값을 저장하는데 특화된 자료형이다

  배열은 객체 자료형에 몇가지 기능을 추가해 다른 언어의 배열처럼 동작하는 특수한 객체이다
  따라서 자바스크립트의 배열에는 일반 객체에 있는 프로퍼티와 메서드가 있다.
*/


// length 프로퍼티 : 배열의 길이를 나타냄
const arr1 = [1,2,3];
console.log(arr1.length); //3

const arr2 = [1,2,3,4];
console.log(arr2.length); //4


// 배열 조작 메서드

// push() : 배열 마지막 요소 뒤에 값을 추가하는 메서드
const arr3 = [1,2,3];
arr3.push(4);

console.log(arr3); // [1,2,3,4]


// name: 함수의 이름을 저장함

function myFunction(){
    console.log('hi');
}

console.log(myFunction.name);



// 객체와 참조
/* 
  원시 자료형은 하나의 값을 저장하지만 함수와 배열은 같은 객체 자료형은 여러 개의 값을 저장합니다.
  원시 자료형은 값을 크기가 일정한 곳에 저장합니다 그러나 객체 자료형은 값이 동적으로 늘어나고 줄어들기때문에 일정한 크기에 저장할 수 없습니다.
  객체 자료형은 값의 크기가 유동적을오 변하기 때무에 자바스크립트는 참조라는 기능이 가능합니다

  참조:실제로 값을 저장하는것이 아니라 값을 저장한 곳의 주소만 저장하는 방식
*/


// 원시 자료형과 객체 자료형의 저장 방식 비교


//원시 자료형은 값을 변수에 저장할 대 값 그대로 저장합니다. 

let numA = 1; //값 1
let numB = 2; //값 2


// 반면 객체 자료형 즉 참조 자료형은 값을 이런식으로 저장합니다

let person = { //변수 person => 참좃값| 주소: 0x0000001 => 값{name:"김현아"}
  name:"김현아"
};
/* 
  객체는 컴퓨터의 메모리 어딘가에 저장되고 변수 person은 객체를 참조할 수 잇는 주솟값을 저장합니다 이값을 참좃값이라고 합니다.
*/

let woman = person;
/* 
  위와같이 객체를 복사하면 변수에는 참좃값이 저장되고 실제 객체값은 복사되지 않습니다. 
  즉 두 변수는 동일한 참좆값을 가지며 하나의 객체를 동시에 참조하는 형태가 됩니다
  변수 woman => 참좃값| 주소: 0x0000001 => 값{name:"김현아"}

  변수 woman에 저장한 객체에 새 프로퍼티를 추가하고 person,woman을 둘다 출력하면 동일한 결과가 나옵니다
  변수 woman과 person이 참조하는 객체가 같기 때문입니다.
  객체 자료형은 원시 자료형과 다르게 참조 형식으로 변수를 저장합니다
*/



// 참조에 의한 비교
/* 
  객체 자료형과 원시 자료형은 저장 방식이 다르기 때문에 값을 비교하는 방법도 다르다
*/

// 원시자료형 예제

let num1 = 1;
let num2 = 2;

console.log(num1 === num2); //true
// 비교한 변수 num1과 num2에 저장한 값은 값도 자료형도 모두 같기때문에 결과는 true입니다


// 객체 자료형 예저

let dev = {
  name: "김현아"
}

let front = {
  nam: "김현아"
}

console.log(dev === front); // false

/* 
  변수 dev와 front에 저장한 객체는 완전히 동일하나 두 값을 비교하면 거짓이 나온다
  객체 자료형을 비교할때는 값이 아닌 참조값을 비교하기 때문이다
  객체 dev와 front는 내부적으로 값이 같으나 각각 별개의 객체이다
  객체를 비교할때 값이 아닌 참조값으로 비교하는것을 "참조에 의한 비교"라고 한다
  배열이나 함수도 객체임으로 당연히 동일한 결과가 출력된다
*/




