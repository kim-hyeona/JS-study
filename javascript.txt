let과 const는 2015년의 탄생한 ES6버전에서 새로 탄생한 문법이다

Var와 Let의 차이 
공통점: Var와 Let는 변수를 선언할때 사용하는 문법이다.
차이점: 
1. 스코프(scope)
자바스크립트에서의 스코프는 코드가 변수에 접근할 수 있는 범위를 뜻함
함수범위(var) 블록범위(let) 전역범위(함수밖 최상단에 선언된 변수 글로벌한 스코프가된다)

즉 var로 선언한 변수는 해당되는 함수까지가 범위지만 let으로 선언한 변수는 블록범위가 함수이다
블록스코프는 블록 외부로부터의 접근을 금지하기에 더 오류로부터 안전하게 코드를 작성할 수 있다


var로 선언한 전역변수와 let으로 선언한 전역변수의 차이
 var로 전역변수를 설정하면 window객체로 설정이 됨
 윈도우객체는 브라우저의 정보를 가지고 있는 단 하나의 객체이다
 이 객체는 작성한 모든 코드와 사용중인 라이브러리들이 공유하고 있는 전역 객체이기에 여러곳에서 접근하고
 값을 변경할 수 있기 때문이다 윈도우객체에 속성을 추가하는것은 위험하다. 
 

 2.중복선언(variavle redeclaration)
 var를 이용하면 같은 변수명을 이용해 중복선언 할 수 있다
 그러나 let키워드는 중복선언을 하지 못하도록 되어있다.


 3.호이스팅(hoisting)
호이스팅이란 프로그램이 실행되기 이전에 변수의 선언과 초기화를 분리하여 변수의 선언부분만 프로그램 맨 위로 끌어올리는것을 말한다 var키워드로 선언된 변수는 호이스팅이되어 맨 위로 끌어올려질때 자동으로 undefined가 출력됨 
let도 var처럼 변수의 선언을 호이스팅하기는 하지만 var와 다르게 변수를 초기화 시키지 않음
그래서 코드상에 있는 선언문 이전에 변수에 접근해도 undefined가 들어있지 않음
let도 var처럼 변수를 호이스팅하나 선언문이 맨위로 끌어올려질때 코드상에 있는 선언문에 닿기까지는 TDZ(Temporal Dead Zone): 일시적 사각지대에 들어가게 됨 자바스크립트는 TDZ에 들어가 있는 변수에게 접근하는것을 허용하지 않는다.



Const: 상수선언

Block Scope / 중복 선언 불가 / 선언문 이전 접근 불가
한번 값을 지정하면 할당 연산자를 사용해서 다시 재할당이 불가능함
선언과 동시에 무조건 초기화를 해줘야함

상수에 할당된 객체는 객체의 속성을 바꾸는 것은 가능
이미 가지고 있는 객체는 유지하면서 내부의 속성을 변경하는것이기때문에 가능함
이것이 변경되는 것을 막고 싶을때는 object.freeze 함수를 이용해서 막을 수 있음



------------------------------------------------------------------------------------------


This와 Bind

자바스크립트에서 This는 어떤 객체를 가르키는 키워드이고 함수를 호출한 객체이다

------------------

전역 문맥에서의 this
전역 문맥에서 그러니까 함수 외부에서 this에 접근하면 window객체를 가르킴

전역 문맥에서 엄격 모드(파일 맨 위에 'use strict' 작성)를 실행시키고 전역적인 문맥에서 this에 접근해도
window객체를 가르킴

/*
엄격모드란?
자바스크립트에서 문법을 좀 더 엄격하게 검사하는 기능
*/

------------------

함수 문맥에서의 this

함수 내부의 this는 함수에서 어떻게 호출했는가에 따라서 값이 달라짐
this는 함수를 호출한 객체이다
function이라는 키워드를 써서 함수를 정의하면 함수는 윈도우 개체에 등록이 됨
전역적으로 함수를 호출한다는건 window.함수명()으로 호출하는 것과 마찬가지이기 때문

그러나 엄격모드를 실행시키고 함수로 this에 접근하면 undefined가 출력됨
엄격모드에서 window개체에 등록할려면 window.함수명()으로 호출하면 됨

객체 메서드에서의 this
메서드란 객체의 속성으로 넣어진 함수를 의미함

객체 메서드 안에서 호출된 함수 속 this는 만들어놓은 오브젝트가 된다
함수안에 있는 this는 함수를 호출한 객체이기때문이다

ex)
const object = {
	name:'이름',
	main: function(){
		console.log(this);
	},
};

object.main(); //main이라는 함수가 object라는 객체가 main이라는 함수를 호출시킨것
		   //그러므로 this는 아래와같은 결과가 나오게 됨

출력값(콘솔창) 
> {name:'별코딩', main: f}

:객체의 다른 속성에 접근할때 유용함
this는 함수를 가르키고 있기 때문에 this.속성명으로 접근이 가능함


------------------


Bind()

동적으로 바뀌는 this값을 하나하나 추적하는것은 번거롭기때문에
this값이 바뀌지 않도록 원하는 객체로 고정하는 작업이 필요할때가 있다

function main(){
	console.log(this);
}

const mainBind = main.bind({name:'hi'}); //bind()는 새로운 함수를 반환한다
						     //main함수에다가 bind를 붙이면 bind는 객체가 this값으로 							함수를 반환해준다 새로운 함수가 mainBind에 들어가서
						      호출해준것
mainBind();


출력값: {name:'hi'}


주의할점: 이미 bind된걸 또 bind할 수 없음

const mainBind = main.bind({name:'hi'});
const mainBindBind = mainBind.bind({}); // 자바스크립트는 이것을 무시함
mainBindBind(); 


ex)
const object = {
    name:'별코딩',
    main: function(){
        console.log(this);
    }.bind({name:'멋진객체'}),
};

object.main();

출력값: {name:'멋진객체'}

------------------

이벤트처리기에서의 this 

const button = docoment.getElementById('btn');

button.addEventListener('click',function(){
    console.log(this);
});

콘솔창: <button id='btn'>버튼</button>

------------------

화살표 함수와 this

화살표 함수는 ES6 버전에서 새로나온 문법
전통적인 함수문법과 다르게 간결하게 함수를 선언 할 수 있음
전통적인 함수 문법은 호출방법에 따른 this 변화가 있고 이를 고정하기 위해
bind()를 사용하나 화살표 함수 문법은 this가 호출에 따라 바뀌지않음
화살표 함수에서 this값은 그 함수를 감싸는 스코프의 this를 그대로 가져와서 사용


------------------------------------------------------------------------------------------

화살표 함수 Basic

    - 일반 함수: 함수 선언식과 함수 표현식

    일반함수: function

        함수 선언식: 자바스크립트에서 함수선언하는 가장 기본적인 방법
            ex) function main(){
                    console.log('hello')
                };

                main()
        
        특징: 호이스팅이 됨 함수의 호이스팅이란 함수가 최상단으로 끌어올려지는것을 말함
                함수의 이름이 필수적이기 때문에 이름이 없는 익명 함수를 만들 수 없음


        함수 표현식: 이름이 없는 익명 함수를 만들 수 있음 
            ex) const main = function() { //익명 함수를 main이란 변수에 할당함
                    console.log('hello')
                }

                main()

        특징: 호이스팅이 되지 않음 함수를 정의하기 이전에 호출하면 에러를 출력함

    - 화살표 함수: 문법 총정리
        ex) const main = () => {
                console.log('hello')
            }

            main()

        * 코드가 한줄일 경우 return과 {}를 생략할 수 있다
        ex) const add = (a,b) => a + b

            add()
        * 코드가 한줄이면서 매개변수가 하나일일 경우 ()를 생략할 수 있다
        ex) const print = text => console.log(text)
            print('hi')

        * 그러나 매개변수가 하나도 없거나 두개 이상일땐 소괄호를 생략할 수 없다

        * 객체를 리턴할때는 객체를 소괄호로 한번 감싸주면 된다
        ex) const getObject = () => ({ name:"이름" })
            
            getObject()

    - arguments와 가변인자

        function 키워드로 정의한 일반 함수의 경우 매개변수로 따로 명시해주지 않아도
        arguments라는 변수를 암묵적으로 전달받는다

        arguments는 함수가 전달받은 매개변수를 담고 있는 배열형태의 객체이다

        function main() {
            console.log(arguments[0]) // console창에 1 출력
        }
        
        main(1,2,3)


        그러나 화살표 함수는 arguments를 전달 받지 않는다!!
        
        화살표함수로 가변인자를 처리하는 법
        ex) const main = (...매개변수이름) => { //나머지 매개변수 구문
            console.log(매개변수이름)
            console.log(매개변수이름[1]) // 2 출력
        }
        main(1,2,3)



화살표 함수 deep dive

    - 일반 함수의 this vs 화살표 함수의 this

        ** 일반함수의 this **
        
            const object = {
                name:'이름',
                main: function() {
                    console.log(this);
                },
            };

            funcion 키워드를 이용해서 생성된 함수에서 this는
            함수를 어떻게 호출하냐에 따라서 값이 달라진다
            this는 함수를 호출한 객체가 되기 때문에 함수를 어떤 객체가 호출했냐에 따라서
            this값이 달라지게 된다

            object.main(); // {name:'이름', main: f} // 어떤 객체가 함수를 호출했는지 알려면 . 표기법 왼쪽에 어떤 객체가 있는지 보면 된다

            일반 함수 안에 있는 디스 값은 이 함수를 호출한 객체가 된다 그래서 만약 main이라는 함수를
            다른 객체에 메서드로서 호출을 하면 이 this값이 달라진다

            const object2 = {
                name:'다른 객체',
                main: object.main // main이라는 함수를 다른 객체에 메서드로서 호출
            }

            object2.main(); // {name:'다른 객체',main: f}


            --------------------
            this는 무조건 함수를 호출한 객체를 가르키게 됨
            funcion 키워드를 사용한 일반 함수는 자기자신만의 this를 갖기 때문에
            함수가 호출되는 런타임의 this를 자신이 호출한 객체에다가 묶어버린다
            이러한 과정을 다이나믹 바인딩 혹은 런타임 바인딩이라고 부른다.
            왜냐하면 일반 함수의 this값은 런타임 곧 함수가 호출되는 시점에서 결정이 되기 때문

            일반 함수의 this는 선언한 위치와 상관없이 호출한 방법에 의해서 값이 출력된다.


            funcion main() {
                console.log(this);
            }

            const object = {
                name:'첫번째 객체',
                main: main,
            }

            const object2 = {
                name:'두번째 객체',
                main: main,
            }

            object.main() // {name:'첫번째 객체',main f}
            object2.main()  // {name:'두번째 객체',main f}

        ** 화살표 함수의 this **
        일반 함수와 다르게 화살표 함수는 자신만의 this를 가지고 있지 않기 때문에
        화살표 함수 내부에서 디스에 접근을 하면 외부로부터 this를 가져와서 사용하게 됨

        화살표 함수는 자신만의 this를 가지고 있지 않아 자신을 감싸고 있는 스코프로 올라가서 this를 찾음
        화살표 함수가 어떤 this값을 가질지 궁금하다면 함수가 선언된곳에 this를 넣어서 확인한다

        화살표 함수의 this값은 함수가 선언된 위치에서 결정이 나는것이다 함수가 호출된 방법과는 무관하다
        화살표 함수를 어떻게 호출했던지 상관없이 화살표 함수가 선언된 시점에서
        this가 결정이 되고 더 이상 바뀌지 않음

        잘 생각해보면 일반 함수랑은 반대로 작동하는건데 일반 함수는 함수가 어디서 선언됐는지
        상관없이 자기자신만의 this값을 가지고 함수가 호출된 방법에 따라서 this값이 바뀜

        메서드 내부에서 this를 통해 객체의 속성에 접근을 해야 될 때가 있는데 
        화살표 함수의 경우에는 this가 함수의 객체가 되지 않는다 그래서 점표기법으로 접근을
        할 수 없게 된다 그렇기 때문에 객체의 메서드로써는 화살표 함수보다 일반 함수가 더
        적합하다
------------------

callback functions 콜백함수

함수는 여러가지 타입의 데이터를 인자로 받을 수 있는데 또 다른 함수까지 인자로 전달받을 수 있다
다른 함수의 인자로 전달되는 함수를 콜백함수라고 한다

콜백함수는 콜백 함수를 전달받은 함수에 의해서 호출이 된다


    funcion main(x) {
        console.log(x); //x라는 매개변수로 sayHi 함수가 들어오게 됨
        x();     // main이 전달받은 x는 함수이기 때문에 함수 뒤에 소괄호를 붙여 콜백함수를 호출할 수 있다
    }            // 이런식으로 콜백함수를 호출하면 sayHi 함수의 값이 출력이 됨

    funcion sayHi() {
        console.log("안냥");
    }

    main(sayHi); // 결과값 f sayHi() {console.log("안냥")}

    콜백함수가 언제 어떻게 호출될지는 메인함수의 구현 사항에 달려있다
    예를 들어서 콜백함수를 호출하기 전에 함수를 호출 시켜줄 수도 있고
    콜백함수를 호출시키고 난 다음에 작업을 실행시킬 수도 있는것이다

    ex) funcion main(x) {
        console.log('준비작업...'); // 콜백함수를 호출시키고 난 다음에 작업
        x();
        console.log('준비작업...'); // 콜백함수를 호출시키기전에 함수작업
    }

    funcion sayHi(){ // 콜백함수
        console.log('안녕')
    }

    main(sayHi);

    자주하는 실수
        main(sayHi());
        
        함수를 인자로 전달할 때 뒤에다가 소괄호를 붙여버리면 이 함수는
        즉각적으로 호출이 되어버림 그래서 결론적으로 함수를 인자로 전달하는게 아니라
        함수의 리턴값을 인자로 전달하는게 되어버린다
        함수의 리턴값이 없을 경우 undefined를 전달하는 것이다

    
함수를 꼭 외부에다가 선언해주지 않고 소괄호 안에다가 그대로 선언해도 된다

funcion main(x) {
    x();
}
main(funcion sayHi() { //바로 인자안에 넣어주었으니 sayHi라는 함수이름없이
    console.log('안녕') //익명함수나 화살표함수로 전달해도 괜찮음
}); 


----------------------------------------------------------------

배열 내장함수

let arr = [1,2,3,4,5];

for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

arr.forEach(); // forEach



----------------------------------------------------------------

react.JS

React.memo로 컴포넌트 최적화하기 (useMemo, useCallback)

컴포넌트에서 무거운 로직을 처리하여 성능에 부담을 준다면 불필요한 렌더링을 최대한 막을 필요가 있다.
리액트에서는 기본적으로 부모 컴포넌트가 렌더링이 되면 모든 자식 컴포넌트들도 자동적으로 렌더링이 된다.
또 매번 같은 결과를 출력하는 컴포넌트가 계속해서 렌더링이 되는 상황이라면 더욱 막을 필요가 있다


React.memo는 리액트에서 제공하는 고차 컴퍼넌트(HOC)이다 

고차컴퍼넌트는 어떤 컴포넌트를 인자로 받아서 새로운 컴포넌트를 반환해 주는 함수이다
React.memo라는 고차 컴포넌트에 어떤 컴포넌트를 넣어주면 ui적으로나 기능적으로는 같지만
좀 더 최적화된 컴포넌트를 반환해준다. 

최적화 된 컴포넌트는 렌더링이 되어야 할 상황에 놓일 때마다 prop Check를 통해서 자신이 받는
props에 변화가 있는지 없는지 확인을 하게 된다.

props에 변화가 있다면 렌더링을 하고 변화가 없다면 렌더링없이 이미 렌더링된 내용을 사용한다

자식 컴포넌트가 React.memo로 최적화가 되어있다면 부모컴포넌트가 렌더링될때
prop Check를 하게된다 자식 컴포넌트가 받는 porps에 변화가 있다면 렌더링을 발생시키고
그렇지 않는 경우에는 새로 렌더링을 하는 게 아니라 이전에 이미 렌더링된 결과를 재사용하는
최적화된 컴포넌트가 된다

React.memo의 memo는 Memoization을 뜻한다
Memoization이란 이미 계산해 놓은 값을 메모리에 저장해놓고 필요할때마다 재사용하는 것을 말함

! React.memo는 꼭 필요할때만 사용한다
    : 무분별하게 사용할 시 성능에 독이 될 수 도 있음
      컴포넌트를 Memoization 할때 렌더링 된 결과를 메모리에 저장해놔야 하기에
      메모리를 추가적으로 사용하기 때문이다

! React.memo는 오직 Props 변화에만 의존하는 최적화 방법이다



 React.memo를 사용하기에 적합한 상황
    1. 컴포넌트가 같은 porps로 인해 변하지 않는 결과값으로 자주 렌더링될때
    2. 컴포넌트가 렌더링이 될때마다 복잡한 로직을 처리해야 될때



-------------------------- React.Fragment  < ></ > --------------------------

ex>
<React.Fragment>
    <h1>제목입니다.</h1>
    <p>컨텐츠 입니다.</p>
</React.Fragment>

리액트 컴포넌트가 리턴하는 엘리먼트들은 단 하나의 최상위 태그로 묶여있어야한다
그래서 주로 여러 컴포넌트를 리턴할때 최상위 태그로 컴포넌트들을 묶을때 div를 사용하는데
문제가 생기는건 아니다만 불필요한 태그를 추가하는 것은 css로 스타일링하기에도 불편하고
테이블 태그를 작성할때 종종 에러를 발생시킨다

리액트 프레그먼트를 사용하면 실제 돔에 별도의 노드를 추가하지 않아도 요소들을 묶어줄 수 있다


map() 사용시 Fragment에 key를 전달할때

const todoList = ['밥먹기','코딩하기','커피 마시기'];

return (
    <>
        {todoList.map((todo, idx) => (
            <React.Fragment key={idx}> // React.Fragment는 props
                <td>{todo}</td>
                <td>{todo}</td>
            </React.Fragment>
            ))}
    </>
)


-------------------------- React Virtual DOM --------------------------

DOM: Document Object Model

    DOM이란 웹페이지에 들어가있는 html 요소들을 트리 형태의 구조로 표현한것
    DOM 트리 속에는 각각 요소가 사용하는 노드가 들어있다.

    개발자들은 DOM이 제공하는 api를 통해서 DOM 구조의 접근을 하고 원하는 요소의
    구조 내용 스타일들을 변경시킬 수 있는데 이런 작업들을 DOM 조작이라고 한다

DOM 조작

    브라우저가 현재 페이지의 HTML을 읽고 해당하는 요소를 찾고
    해당하는 요소와 자녀요소를 DOM에서 제거한다 그리고 새롭게 수정된 요소들로 교체한다
    그러고 나서 CSS를 다시 읽고내고 레어어 정보를 수정하고 브라우저에 새로 출력한다


Virtual DOM: 가상돔

    실제 DOM과 같은 내용을 담고 있는 복사본 같은 개념으로
    실제 DOM이 아닌 자바스크립트의 객체 형태로 메모리 속에 저장되어 있다

    가상 DOM은 실제 DOM 안에 있는 모든 엘리먼트들과 속성들을 똑같이 갖고 있지만
    실제 DOM과 다르게 브라우저에 있는 문서에 직접적으로 접근을 할 수 없다
    그렇기 때문에 화면에 보여지는 내용을 직접 수정할 수 없다


Virtual DOM 조작

    실제 DOM과는 다르게 직접적으로 화면에 보이는 요소를 조작할 수 있는 API를 제공하지 않음
    가상 DOM은 메모리에 저장되어 있는 자바스크립트 객체이기 때문이다.
    이러한 점때문에 빠르게 속도를 낼 수 있는 것이다 실제 브라우저 화면에 접근하는게 아니기 때문이다

    리액트는 항상 2개의 가상 DOM 객체를 가지고 있다

    1. 렌더링 이전
        화면구조를 나타내는 가상 돔

    2. 렌더링 이후에 보이게 될 화면 구조를 나타내는 돔


    리액트는 state가 변경될때마다 화면이 새로 렌더링이 된다
    리액트는 렌더링이 발생 될 상황에 놓일 때마다 실제 브라우저에 그려지기 이전에
    새로운 화면에 들어갈 내용이 담긴 가상 돔을 생성하고
    렌더링 이전 화면의 내용을 담고 있는 첫번째 가상DOM과 업데이트 이후의 내용을 담고 있는
    가상 DOM을 비교해서 정확히 어느 엘리먼트들이 변했는지 찾아낸다
        => 이러한 과정들을 Diffing 디핑이라고 부른다
            Diffing은 효율적인 알고리즘을 사용해서 정확히 어느 요소들이 변경되었는지
            굉장히 빠르게 파악할 수 있다 이렇게 바뀐 요소들을 파악한다음에
            그 부분만 실제 돔에 적용시켜준다 
            => 이러한 과정들은 Reconsiliation 리컨스텔레이션 곧 재조정이라고 부른다
                리액트의 Reconsiliation이 효율적인 이유는 Batch Update때문인데
                Batch는 집단 / 무리라는 뜻으로 Batch Update한 변경된 모든 요소들을
                집단으로 실제 DOM에 한번에 적용시켜준다


 정리

 1. 리액트의 가상 돔은 실제 돔과 같은 내용을 담고 있는 복사본이며 자바스크립트 객체의 형태로
 메모리상에 저장되어있다.

 2. 리액트는 항상 두개의 가상 돔을 가지고 있다. 
    첫번째는 가상돔 변경 이전의 내용 두번째 가상돔은 변경 이후에 보여질 내용을 담고 있다.

 3. 변경된 내용이 화면에 새롭게 그려지기 이전, 곧 실제 돔이 변경되기 전에
    리액트는 가상 돔 두개를 비교하여 정확히 어떤 부분이 변경되었는가를 비교한다
    이러한 과정을 Diffing이라고 부른다

 4. Diffing을 통해서 변경된 부분들을 파악한 이후에, 리액트는 Batch Update를 수행하여
    실제 돔에 한번에 적용시킨다 그리고 이러한 과정을 Reconsiliation 리컨스텔레이션 곧 재조정이라고 부른다




-------------------------- React의 ForwardRef / Ref 전달하기 --------------------------

ForwardRef는 부모 컴포넌트에서 자녀 컴포넌트로 Ref를 전달할때 사용하는 기법이다

부모컴포넌트가 자녀컴포넌트의 돔 요소에 접근해야할때 유용하게 사용할 수 있다

ex> 

*****부모 컴포넌트*****

    const inputRef = useRef();

    const focus = () => {
        inputRef.current.focus();
    };

    return(
        <div>
            <MyInput ref={inputRef} />
            <button onClick={focus}>포커스</button>
        </div>
    )

*****자녀 컴포넌트*****
    const MyInput = (props, ref) => { //ForwardRef로 감싸진 자녀 컴포넌트는 새로운 두번째 인자를
        return <input ref={ref} />;   // 받게 되는데 여기에 부모에게서 전달받은 ref가 들어있게 된다
    };                                // 이제 자녀 컴포넌트는 전달받은 ref를 속성으로 넣어주면 된다

    export default ForwardRef(MyInput) //리액트에서 제공하는 ForwardRef로 감싸주면 된다



ForwardRef 주의할점

    부모컴포넌트에서 자녀컴포넌트로 Ref를 전달할때 ForwardRef를 사용하면
    마치 기본적인 요소에 Ref를 전달하듯 전달해줄 수 있으며 재사용성이 높은 자녀 컴포넌트라면
    ForwardRef를 사용해서 유연하게 노드에 접근 할 수 있다

    그러나 지나친 유연성은 오히려 성능을 해칠 수 있다

    자녀의 돔 노드에 접근한다는건 자녀 컴포넌트의 캡슐화의 대한 장점을 없애버린다
    자녀 컴포넌트가 갖고 있는 돔 노드를 외부로 외부로 노출시키기 때문이다

    요소에 포커스를 준다던가 애니메이션을 관리한다던지 돔 노드에 접근하는게 불가피할때만
    ForwardRef를 사용하는 것이다